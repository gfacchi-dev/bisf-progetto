# Plot per confronto con distribuzione normale
qqnorm(CCRmonthly, col="blue", lwd=2)
qqline(CCRmonthly, col="red", lwd=2)
}
# Plot dei grafici diagnostici
CCRdiagnosticGraphs(TEN.MI.CCReturnMonthly, title = "TEN.MI")
CCRdiagnosticGraphs(ENI.MI.CCReturnMonthly, title = "ENI.MI")
CCRdiagnosticGraphs(EXO.MI.CCReturnMonthly, title = "EXO.MI")
CCRdiagnosticGraphs(AZM.MI.CCReturnMonthly, title = "AZM.MI")
CCRdiagnosticGraphs(REC.MI.CCReturnMonthly, title = "REC.MI")
CCRdiagnosticGraphs(DIA.MI.CCReturnMonthly, title = "DIA.MI")
#BOXPLOTS PER CONFRONTO
par(mfrow=c(1,1))
boxplot(list( TEN.MI=as.numeric(TEN.MI.CCReturnMonthly),
ENI.MI=as.numeric(ENI.MI.CCReturnMonthly),
EXO.MI=as.numeric(EXO.MI.CCReturnMonthly),
AZM.MI=as.numeric(AZM.MI.CCReturnMonthly),
REC.MI=as.numeric(REC.MI.CCReturnMonthly),
DIA.MI=as.numeric(DIA.MI.CCReturnMonthly)),
col = "orange",
ylab="Variazione % mensile (%)",
xlab="Titoli azionari",
main="Boxplots per analisi dei CC returns mensili dei titoli azionari")
abline(h=0.0, lty=2, lwd=2, col="blue")
View(EXO.MI.CCReturnMonthly)
rm(list=ls())
library(quantmod)
library(PerformanceAnalytics)
library(dygraphs)
library(tseries)
library(shiny)
stockNames <- c("TEN.MI", "ENI.MI", "EXO.MI", "AZM.MI", "REC.MI", "DIA.MI")
for (s in stockNames) {
getSymbols(s, source="yahoo")
}
rm(s)
startDate <- as.Date("2018-10-1")
endDate <- as.Date("2020-10-1")
TEN.MI <- window(TEN.MI, start = startDate, end = endDate)[,6]
ENI.MI <- window(ENI.MI, start = startDate, end = endDate)[,6]
EXO.MI <- window(EXO.MI, start = startDate, end = endDate)[,6]
AZM.MI <- window(AZM.MI, start = startDate, end = endDate)[,6]
DIA.MI <- window(DIA.MI, start = startDate, end = endDate)[,6]
REC.MI <- window(REC.MI, start = startDate, end = endDate)[,6]
stocks <- round(x = merge(TEN.MI, ENI.MI, EXO.MI, AZM.MI, REC.MI, DIA.MI ), digits = 2)
colnames(stocks) <- stockNames
tformat(stocks) <- "%d %B %y"
stocks <- na.omit(stocks)
stocks.compoundReturns <- round(Return.calculate(to.monthly(stocks, OHLC = FALSE), method = "compound"), digits=2)[-1,]
setwd("./webapp")
source("server.r")
source("ui.r")
shinyApp(ui, server)
rm(list=ls())
library(quantmod)
library(Amelia)
library(knitr)
library(dygraphs)
library(PerformanceAnalytics)
library(PortfolioAnalytics)
library(shiny)
library(reshape2)
library(tseries)
library(scales)
library(data.table)
library(zoo)
library(datasets)
library(forecast)
library(lubridate)
#-------------------------------DESCRIPTIVE ANALYTICS-------------------------------
# Nomi degli stocks
stockNames <- c("TEN.MI", "ENI.MI", "EXO.MI", "AZM.MI", "REC.MI", "DIA.MI")
for (s in stockNames) {
getSymbols(s, source="yahoo")
}
rm(s)
# Finestra temporale dal 1 Ottobre 2018 al 1 Ottobre 2020
startDate <- as.Date("2018-10-1")
endDate <- as.Date("2020-10-1")
TEN.MI <- window(TEN.MI, start = startDate, end = endDate)[,6]
ENI.MI <- window(ENI.MI, start = startDate, end = endDate)[,6]
EXO.MI <- window(EXO.MI, start = startDate, end = endDate)[,6]
AZM.MI <- window(AZM.MI, start = startDate, end = endDate)[,6]
DIA.MI <- window(DIA.MI, start = startDate, end = endDate)[,6]
REC.MI <- window(REC.MI, start = startDate, end = endDate)[,6]
# Merging dei dati in una struttura unica
stocks <- round(x = merge(TEN.MI, ENI.MI, EXO.MI, AZM.MI, REC.MI, DIA.MI ), digits = 2)
colnames(stocks) <- stockNames
tformat(stocks) <- "%d %B %y"
par(mfrow=c(1,1))
missmap(stocks, legend = FALSE)
# Omissione degli NA
stocks <- na.omit(stocks)
# Rivisualizzazione della missmap senza NA
missmap(stocks, legend = FALSE)
#Summary dei dati aggregati
kable(summary(stocks))
# Funzione per il plot degli adjusted close prices di uno stock
valueChart <- function(adjusteds, title) {
dygraph(
adjusteds,
main = paste("Andamento del valore del titolo", title, "dal", format(startDate, "%d-%m-%y"), "al",  format(endDate, "%d-%m-%y"), sep=" ", collapse=NULL),
ylab = "Valore (EUR)",
xlab = "Data") %>%
dyRangeSelector()
}
# Plot dei grafici degli adjusted close prices
valueChart(adjusteds = stocks$TEN.MI, title="Tenaris S.A.")
valueChart(adjusteds = stocks$ENI.MI, title="Eni S.p.A.")
valueChart(adjusteds = stocks$EXO.MI, title="Exor N.V.")
valueChart(adjusteds = stocks$AZM.MI, title="Azimut Holding S.p.A.")
valueChart(adjusteds = stocks$REC.MI, title="Recordati S.p.A.")
valueChart(adjusteds = stocks$DIA.MI, title="DiaSorin S.p.A.")
TEN.MI.CCReturnMonthly <- round(x=Return.calculate(to.monthly(stocks$TEN.MI), method = "compound"), digits=2)[,4]
# Impostazione del ritorno del primo mese (ottobre 2018) a 0%
TEN.MI.CCReturnMonthly <- na.fill(TEN.MI.CCReturnMonthly, 0)
TEN.MI.CCReturnYearly <-  round(x=Return.calculate(to.yearly(stocks$TEN.MI), method = "compound"), digits=2)[,4]
TEN.MI.CCReturnYearly <- na.fill(TEN.MI.CCReturnYearly, 0)
ENI.MI.CCReturnMonthly <- round(x=Return.calculate(to.monthly(stocks$ENI.MI), method = "compound"), digits=2)[,4]
ENI.MI.CCReturnMonthly <- na.fill(ENI.MI.CCReturnMonthly, 0)
ENI.MI.CCReturnYearly <-  round(x=Return.calculate(to.yearly(stocks$ENI.MI), method = "compound"), digits=2)[,4]
ENI.MI.CCReturnYearly <- na.fill(ENI.MI.CCReturnYearly, 0)
EXO.MI.CCReturnMonthly <- round(x=Return.calculate(to.monthly(stocks$EXO.MI), method = "compound"), digits=2)[,4]
EXO.MI.CCReturnMonthly <- na.fill(EXO.MI.CCReturnMonthly, 0)
EXO.MI.CCReturnYearly <-  round(x=Return.calculate(to.yearly(stocks$EXO.MI), method = "compound"), digits=2)[,4]
EXO.MI.CCReturnYearly <- na.fill(EXO.MI.CCReturnYearly, 0)
AZM.MI.CCReturnMonthly <- round(x=Return.calculate(to.monthly(stocks$AZM.MI), method = "compound"), digits=2)[,4]
AZM.MI.CCReturnMonthly <- na.fill(AZM.MI.CCReturnMonthly, 0)
AZM.MI.CCReturnYearly <-  round(x=Return.calculate(to.yearly(stocks$AZM.MI), method = "compound"), digits=2)[,4]
AZM.MI.CCReturnYearly <- na.fill(AZM.MI.CCReturnYearly, 0)
DIA.MI.CCReturnMonthly <- round(x=Return.calculate(to.monthly(stocks$DIA.MI), method = "compound"), digits=2)[,4]
DIA.MI.CCReturnMonthly <- na.fill(DIA.MI.CCReturnMonthly, 0)
DIA.MI.CCReturnYearly <-  round(x=Return.calculate(to.yearly(stocks$DIA.MI), method = "compound"), digits=2)[,4]
DIA.MI.CCReturnYearly <- na.fill(DIA.MI.CCReturnYearly, 0)
REC.MI.CCReturnMonthly <- round(x=Return.calculate(to.monthly(stocks$REC.MI), method = "compound"), digits=2)[,4]
REC.MI.CCReturnMonthly <- na.fill(REC.MI.CCReturnMonthly, 0)
REC.MI.CCReturnYearly <-  round(x=Return.calculate(to.yearly(stocks$REC.MI), method = "compound"), digits=2)[,4]
REC.MI.CCReturnYearly <- na.fill(REC.MI.CCReturnYearly, 0)
#Visualizzazione degli adjusted close prices degli stock considerati insieme
dygraph(stocks,
main = paste("Andamento del valore dei titoli azionari dal", format(startDate, "%d %B %y"), "al",  format(endDate, "%d %B %y"), sep=" ", collapse=NULL),
ylab = "Valore (EUR)",
xlab = "Data") %>%
dyRangeSelector()
#VARIAZIONE % DEI RITORNI SEMPLICI DEI TITOLI AZIONARI
stocks.simpleReturns <- round(Return.calculate(to.monthly(stocks, OHLC = FALSE), method = "simple"), digits=2)
stocks.simpleReturns <- na.fill(stocks.simpleReturns, 0)
kable(summary(stocks.simpleReturns))
print(stocks.simpleReturns)
dygraph(stocks.simpleReturns,
main = paste("Variazione % mensile del valore dei titoli azionari dal", format(startDate, "%d %B %y"), "al",  format(endDate, "%d %B %y"), sep=" ", collapse=NULL),
ylab = "Variazione (%)",
xlab = "Mese")%>%
dyRangeSelector()
#VARIAZIONE % CCR DEI TITOLI AZIONARI
stocks.compoundReturns <- round(Return.calculate(to.monthly(stocks, OHLC = FALSE), method = "compound"), digits=2)
stocks.compoundReturns <- na.fill(stocks.compoundReturns, 0)
kable(summary(stocks.compoundReturns))
print(stocks.compoundReturns)
dygraph(stocks.compoundReturns,
main = paste("Variazione % dei CCR mensili dei titoli azionari dal", format(startDate, "%d %B %y"), "al",  format(endDate, "%d %B %y"), sep=" ", collapse=NULL),
ylab = "Variazione (%)",
xlab = "Data")%>%
dyRangeSelector()
# Funzione per la visualizzazione contemporanea dei ritorni di due stock di settori distinti
sectorCCRgraph <- function(adjustedsOne, companyOne, adjustedsTwo, companyTwo, sectorTitle) {
sector.compoundReturns <- round(Return.calculate(to.monthly(merge(adjustedsOne, adjustedsTwo), OHLC = FALSE), method = "compound"), digits=2)[-1,]
colnames(sector.compoundReturns) <- c(companyOne, companyTwo)
dygraph(sector.compoundReturns,
main = paste("Variazione % dei CCR mensili del settore", sectorTitle, "dal", format(startDate, "%d %B %y"), "al",  format(endDate, "%d %B %y"), sep=" ", collapse=NULL),
ylab = "Variazione (%)",
xlab = "Data")%>%
dyOptions(fillGraph =TRUE) %>%
dyRangeSelector()
}
#COMPARAZIONE CCR MENSILE TITOLI SETTORE OIL&GAS
sectorCCRgraph(stocks$TEN.MI, "TEN.MI", stocks$ENI.MI, "ENI.MI", "Oil&Gas")
#COMPARAZIONE CCR MENSILE TITOLI SETTORE FINANCE
sectorCCRgraph(stocks$EXO.MI, "EXO.MI", stocks$AZM.MI, "AZM.MI", "Finance")
#COMPARAZIONE CCR MENSILE TITOLI SETTORE BIOTECH
sectorCCRgraph(stocks$DIA.MI, "DIA.MI", stocks$REC.MI, "REC.MI", "BioTech")
#GRAFICI DIAGNOSTICI
library(ggplot2)
CCRdiagnosticGraphs <- function(CCRmonthly, title) {
par(mfrow=c(2,2))
# Istogramma per la visualizzazione della frequenza delle occorenze dei CCR
hist(CCRmonthly,
breaks = 15,
freq = FALSE,
main=paste("Distribuzione dei CCR dello stock", title, sep=" ", collapse=NULL),
xlab = "CCR (%)",
ylab = "Frequenza del CCR (%)")
# Linea di densità
lines(density(CCRmonthly),
col = "red",
lwd = 3)
# Boxplot per analisi della distribuzione dei CCR
boxplot(as.numeric(CCRmonthly),
horizontal = TRUE,
col="orange",
xlab="% CCR",
main=paste("Boxplot dei CCR mensili dello stock", title, sep=" ", collapse=NULL))
# Smoothed Density dei CCR
plot(density(CCRmonthly),
type = "l",
xlab =  paste("CCR mensili dello stock", title, sep=" ", collapse=NULL),
col = "purple",
lwd = 3,
ylab = "Densità di probabilità",
main = paste("Densità di probabilità del rel. valore di CCR", title, sep=" ", collapse=NULL))
# Plot per confronto con distribuzione normale
qqnorm(CCRmonthly, col="blue", lwd=2)
qqline(CCRmonthly, col="red", lwd=2)
}
# Plot dei grafici diagnostici
CCRdiagnosticGraphs(TEN.MI.CCReturnMonthly, title = "TEN.MI")
CCRdiagnosticGraphs(ENI.MI.CCReturnMonthly, title = "ENI.MI")
CCRdiagnosticGraphs(EXO.MI.CCReturnMonthly, title = "EXO.MI")
CCRdiagnosticGraphs(AZM.MI.CCReturnMonthly, title = "AZM.MI")
CCRdiagnosticGraphs(REC.MI.CCReturnMonthly, title = "REC.MI")
CCRdiagnosticGraphs(DIA.MI.CCReturnMonthly, title = "DIA.MI")
#BOXPLOTS PER CONFRONTO
par(mfrow=c(1,1))
boxplot(list( TEN.MI=as.numeric(TEN.MI.CCReturnMonthly),
ENI.MI=as.numeric(ENI.MI.CCReturnMonthly),
EXO.MI=as.numeric(EXO.MI.CCReturnMonthly),
AZM.MI=as.numeric(AZM.MI.CCReturnMonthly),
REC.MI=as.numeric(REC.MI.CCReturnMonthly),
DIA.MI=as.numeric(DIA.MI.CCReturnMonthly)),
col = "orange",
ylab="Variazione % mensile (%)",
xlab="Titoli azionari",
main="Boxplots per analisi dei CC returns mensili dei titoli azionari")
abline(h=0.0, lty=2, lwd=2, col="blue")
# Calcolo delle statistiche di media, varianza, dev. standard, kurtosis, skewness e quantili
TEN.MI.media <- mean(TEN.MI.CCReturnMonthly)
TEN.MI.varianza <- var(TEN.MI.CCReturnMonthly)
TEN.MI.stddev <- sd(TEN.MI.CCReturnMonthly)
TEN.MI.kurtosis <- kurtosis(TEN.MI.CCReturnMonthly)
TEN.MI.skewness <- skewness(TEN.MI.CCReturnMonthly)
quantile(TEN.MI.CCReturnMonthly)
ENI.MI.media <- mean(ENI.MI.CCReturnMonthly)
ENI.MI.varianza <- var(ENI.MI.CCReturnMonthly)
ENI.MI.stddev <- sd(ENI.MI.CCReturnMonthly)
ENI.MI.kurtosis <- kurtosis(ENI.MI.CCReturnMonthly)
ENI.MI.skewness <- skewness(ENI.MI.CCReturnMonthly)
quantile(ENI.MI.CCReturnMonthly)
EXO.MI.media <- mean(EXO.MI.CCReturnMonthly)
EXO.MI.varianza <- var(EXO.MI.CCReturnMonthly)
EXO.MI.stddev <- sd(EXO.MI.CCReturnMonthly)
EXO.MI.kurtosis <- kurtosis(EXO.MI.CCReturnMonthly)
EXO.MI.skewness <- skewness(EXO.MI.CCReturnMonthly)
quantile(EXO.MI.CCReturnMonthly)
AZM.MI.media <- mean(AZM.MI.CCReturnMonthly)
AZM.MI.varianza <- var(AZM.MI.CCReturnMonthly)
AZM.MI.stddev <- sd(AZM.MI.CCReturnMonthly)
AZM.MI.kurtosis <- kurtosis(AZM.MI.CCReturnMonthly)
AZM.MI.skewness <- skewness(AZM.MI.CCReturnMonthly)
quantile(AZM.MI.CCReturnMonthly)
REC.MI.media <- mean(REC.MI.CCReturnMonthly)
REC.MI.varianza <- var(REC.MI.CCReturnMonthly)
REC.MI.stddev <- sd(REC.MI.CCReturnMonthly)
REC.MI.kurtosis <- kurtosis(REC.MI.CCReturnMonthly)
REC.MI.skewness <- skewness(REC.MI.CCReturnMonthly)
quantile(REC.MI.CCReturnMonthly)
DIA.MI.media <- mean(DIA.MI.CCReturnMonthly)
DIA.MI.varianza <- var(DIA.MI.CCReturnMonthly)
DIA.MI.stddev <- sd(DIA.MI.CCReturnMonthly)
DIA.MI.kurtosis <- kurtosis(DIA.MI.CCReturnMonthly)
DIA.MI.skewness <- skewness(DIA.MI.CCReturnMonthly)
quantile(DIA.MI.CCReturnMonthly)
# Statistiche aggregate di media, varianza, dev. standard, kurtosis, skewness e quantili
aggr.media <- c(TEN.MI.media,
ENI.MI.media,
EXO.MI.media,
AZM.MI.media,
REC.MI.media,
DIA.MI.media)
aggr.varianza <- c(TEN.MI.varianza,
ENI.MI.varianza,
EXO.MI.varianza,
AZM.MI.varianza,
REC.MI.varianza,
DIA.MI.varianza)
aggr.stddev <- c(TEN.MI.stddev,
ENI.MI.stddev,
EXO.MI.stddev,
AZM.MI.stddev,
REC.MI.stddev,
DIA.MI.stddev)
aggr.kurtosis <- c(TEN.MI.kurtosis,
ENI.MI.kurtosis,
EXO.MI.kurtosis,
AZM.MI.kurtosis,
REC.MI.kurtosis,
DIA.MI.kurtosis)
aggr.skewness <- c(TEN.MI.skewness,
ENI.MI.skewness,
EXO.MI.skewness,
AZM.MI.skewness,
REC.MI.skewness,
DIA.MI.skewness)
stats <- data.frame(aggr.media, aggr.varianza, aggr.stddev, aggr.kurtosis, aggr.skewness)
rownames(stats) <- stockNames
# Sommario statistiche aggregate
kable(summary(stats))
# Visualizzazione delle statistiche
print(stats)
# Record con media/dev std massima/minima
media.max <- stats[which.max(stats$aggr.media),]
media.min <-stats[which.min(stats$aggr.media),]
stddev.max <-stats[which.max(stats$aggr.stddev),]
stddev.min <-stats[which.min(stats$aggr.stddev),]
#Visualizzazione statistiche media/dev std massima/minima
print(paste0("Titolo con Media MAX: ", rownames(media.max), " --> ", media.max$aggr.media))
print(paste0("Titolo con Media MIN: ", rownames(media.min), " --> ", media.min$aggr.media))
print(paste0("Titolo con Dev STD MAX: ", rownames(stddev.max), " --> ", stddev.max$aggr.media))
print(paste0("Titolo con Dev STD MIN: ", rownames(stddev.min), " --> ", stddev.min$aggr.media))
# Volatilità media dei titoli
par(mfrow = c(1, 1))
names(aggr.stddev) <- stockNames
barplot(aggr.stddev, col="red", main = "Volatilità Dei Titoli (DEV STD)")
# QQPlots per confronto con distribuzioni normali
par(mfrow=c(3,2))
qqnorm(TEN.MI.CCReturnMonthly, main = "QQ-PLOT TEN.MI", col = "red")
qqline(TEN.MI.CCReturnMonthly)
qqnorm(ENI.MI.CCReturnMonthly, main = "QQ-PLOT ENI.MI", col = "green")
qqline(ENI.MI.CCReturnMonthly)
qqnorm(EXO.MI.CCReturnMonthly, main = "QQ-PLOT EXO.MI", col = "blue")
qqline(EXO.MI.CCReturnMonthly)
qqnorm(AZM.MI.CCReturnMonthly, main = "QQ-PLOT AZM.MI", col = "purple")
qqline(AZM.MI.CCReturnMonthly)
qqnorm(REC.MI.CCReturnMonthly, main = "QQ-PLOT REC.MI", col = "black")
qqline(REC.MI.CCReturnMonthly)
qqnorm(DIA.MI.CCReturnMonthly, main = "QQ-PLOT DIA.MI", col = "brown")
qqline(DIA.MI.CCReturnMonthly)
# Conversione numerica dei ritorni mensili per la visualizzazione nella matrice di correlazione
TEN.MI.mat <- coredata(TEN.MI.CCReturnMonthly)
ENI.MI.mat <- coredata(ENI.MI.CCReturnMonthly)
EXO.MI.mat <- coredata(EXO.MI.CCReturnMonthly)
AZM.MI.mat <- coredata(AZM.MI.CCReturnMonthly)
REC.MI.mat <- coredata(REC.MI.CCReturnMonthly)
DIA.MI.mat <- coredata(DIA.MI.CCReturnMonthly)
bindedvalues <- cbind(TEN.MI.mat,ENI.MI.mat, EXO.MI.mat, AZM.MI.mat, REC.MI.mat, DIA.MI.mat)
colnames(bindedvalues) <- stockNames
# Matrice di correlazione semplice
pairs(bindedvalues, pch=18, col="blue", main="Matrice di Correlazione tra i titoli azionari")
# Calcolo della matrice di Covarianza
cov(bindedvalues)
# Correlazione
library(heatmaply)
# Calcolo della matrice di Correlazione
cor_matrix <- cor(bindedvalues)
# Heatmap di Correlazione
heatmaply_cor(
cor_matrix,
xlab = "Titoli",
k_col = 2,
k_row = 2
)
# Dataset contenente tutti gli RMSE dei vari modelli ARMA predittivi,
#   verrà selezionato quello minore per ogni stock
rmseColl <- c()
# Funzione di Forecast, con n -> length training set, m -> length test set, l -> length final set
generateForecastArima <- function(stockName, n, m, l) {
# Riscarico la ts completa per il forecast con granularità mensile
dataset.z <- get.hist.quote( instrument=stockName, start="2007-01-01", quote="AdjClose", provider="yahoo", origin="1970-01-01", compression="month")
dataset.z <- na.omit(dataset.z)
# Cambio l'indice della ts utilizzando mese/anno
index(dataset.z) <- as.yearmon(index(dataset.z))
colnames(dataset.z) <- stockName
dataset.z <- aggregate(dataset.z, index(dataset.z), tail, 1)
index(dataset.z) <- as.yearmon(index(dataset.z))
#Calcolo i CC returns
returns <- diff(log(dataset.z[,1]))
# Plotto la seasonal decomposition dello stock per analisi sulla periodicità
fitRet <- stl(returns[,1], s.window="period")
plot(fitRet, main=paste("Seasonal Decomposition of, ", stockName ," CC Returns Time Series"))
# Divido tra training e test set
returnsTrain <- returns[(length(returns) - (n + m + l)):(length(returns) - (m + l))]
returnsTest <- returns[(length(returns) - (m + l)):(length(returns) - (l + 1))]
# Computo tutti i modelli di ARMA prediction per 0<=ar<=10 i=0  0<=ma<=10
for(ar in 1:10){
for(ma in 1:10){
# Provo a trovare un modello per la corrente configurazione di arima, se non lo trovo avrò null
try (fit <- arima(returnsTrain, order = c(ar, 0, ma)))
# Se il modello è diverso da null plotto la predizione e il relativo confronto con i ritorni di test
if(!is.null(fit)){
#arma.predictions <- predict(fit, n.ahead = ((length(returns) - l) - (length(returns)-(m + l + 1))))$pred
arma.predictions <- predict(fit, n.ahead = (length(returnsTest)))$pred
arma.forecast <- forecast(fit, h = length(returnsTest),level = c(95, 80))
plot(arma.forecast, main = paste0("ARMA (ar=",ar,", ma=",ma,") forecasts for ", stockName, " returns"), xlab = "Data", ylab = "Ritorno (%)")
grid()
lines(returnsTest)
# Appendo al dataset degli RMSE la configurazione attuale di ARIMA con il relativo RMSE
rmseColl <<- rbind(rmseColl, c(stockName, accuracy(arma.predictions, returnsTest)[2], ar, 0, ma))
lines(returnsTest)
}
}
}
}
m <- 80
n <- 30
l <- 10
#Forecasting su tutti gli stocks con 80 mesi in training, 30 in test e 10 nella porzione finale
generateForecastArima("TEN.MI", m, n, l)
generateForecastArima("ENI.MI", m, n, l)
generateForecastArima("EXO.MI", m, n, l)
generateForecastArima("AZM.MI", m, n, l)
generateForecastArima("REC.MI", m, n, l)
generateForecastArima("DIA.MI", m, n, l)
rmseColl <- as.data.frame(rmseColl)
colnames(rmseColl) <- c("Stock", "RMSE", "ar", "i", "ma")
rmseColl$RMSE <-as.numeric(as.character(rmseColl$RMSE))
# Dataset di analisi di output
minErrorModel <- c()
TEN.MI.Models <- rmseColl[rmseColl$Stock == "TEN.MI",]
minErrorModel <- rbind(minErrorModel, TEN.MI.Models[which.min(TEN.MI.Models$RMSE),])
ENI.MI.Models <- rmseColl[rmseColl$Stock == "ENI.MI",]
minErrorModel <- rbind(minErrorModel, ENI.MI.Models[which.min(ENI.MI.Models$RMSE),])
EXO.MI.Models <- rmseColl[rmseColl$Stock == "EXO.MI",]
minErrorModel <- rbind(minErrorModel, EXO.MI.Models[which.min(EXO.MI.Models$RMSE),])
AZM.MI.Models <- rmseColl[rmseColl$Stock == "AZM.MI",]
minErrorModel <- rbind(minErrorModel, AZM.MI.Models[which.min(AZM.MI.Models$RMSE),])
REC.MI.Models <- rmseColl[rmseColl$Stock == "REC.MI",]
minErrorModel <- rbind(minErrorModel, REC.MI.Models[which.min(REC.MI.Models$RMSE),])
DIA.MI.Models <- rmseColl[rmseColl$Stock == "DIA.MI",]
minErrorModel <- rbind(minErrorModel, DIA.MI.Models[which.min(DIA.MI.Models$RMSE),])
View(minErrorModel)
# Funzione per il calcolo dinamico di beta
beta_function <- function(stock, market_index){
beta <- cov(stock, market_index)/var(market_index)
return(beta)
}
# Per il compute dei beta faccio il retrieve dei ritorni compounded mensili dell'indice di mercato di
#   riferimento (FTSE MIB)
getSymbols("FTSEMIB.MI", source="yahoo")
FTSEMIB.MI <- window(FTSEMIB.MI, start = startDate, end = endDate)[,6]
FTSEMIB.MI.CCReturnMonthly <- round(x=Return.calculate(to.monthly(FTSEMIB.MI), method = "compound"), digits=2)[,4]
FTSEMIB.MI.CCReturnMonthly <- na.fill(FTSEMIB.MI.CCReturnMonthly, 0)
# Calcolo dei Beta semplici per la finestra temporale
beta_TEN.MI <- beta_function(TEN.MI.CCReturnMonthly, FTSEMIB.MI.CCReturnMonthly)
beta_ENI.MI <- beta_function(ENI.MI.CCReturnMonthly, FTSEMIB.MI.CCReturnMonthly)
beta_EXO.MI <- beta_function(EXO.MI.CCReturnMonthly, FTSEMIB.MI.CCReturnMonthly)
beta_AZM.MI <- beta_function(AZM.MI.CCReturnMonthly, FTSEMIB.MI.CCReturnMonthly)
beta_REC.MI <- beta_function(REC.MI.CCReturnMonthly, FTSEMIB.MI.CCReturnMonthly)
beta_DIA.MI <- beta_function(DIA.MI.CCReturnMonthly, FTSEMIB.MI.CCReturnMonthly)
# Beta aggregati
disp <- cbind(beta_TEN.MI, beta_ENI.MI, beta_EXO.MI, beta_AZM.MI, beta_REC.MI, beta_DIA.MI)
colnames(disp) <- stockNames
rownames(disp) <- "Beta"
kable(disp)
# ---Calcolo di beta per diverse finestre temporali---
TEN.MI_betas.xts <- NULL
ENI.MI_betas.xts <- NULL
EXO.MI_betas.xts <- NULL
AZM.MI_betas.xts <- NULL
DIA.MI_betas.xts <- NULL
REC.MI_betas.xts <- NULL
# Finestra temporale (mesi)
delta_t <- 6
length_period = dim(FTSEMIB.MI.CCReturnMonthly)[1]
start <- delta_t + 1
par(mfrow = c(1, 1))
for (i in start:length_period){
beta_val_TEN.MI <- beta_function(TEN.MI.CCReturnMonthly[(i-delta_t):(i-1)], FTSEMIB.MI.CCReturnMonthly[(i-delta_t):(i-1)])
beta_val_ENI.MI <- beta_function(ENI.MI.CCReturnMonthly[(i-delta_t):(i-1)], FTSEMIB.MI.CCReturnMonthly[(i-delta_t):(i-1)])
beta_val_EXO.MI <- beta_function(EXO.MI.CCReturnMonthly[(i-delta_t):(i-1)], FTSEMIB.MI.CCReturnMonthly[(i-delta_t):(i-1)])
beta_val_AZM.MI <- beta_function(AZM.MI.CCReturnMonthly[(i-delta_t):(i-1)], FTSEMIB.MI.CCReturnMonthly[(i-delta_t):(i-1)])
beta_val_REC.MI <- beta_function(REC.MI.CCReturnMonthly[(i-delta_t):(i-1)], FTSEMIB.MI.CCReturnMonthly[(i-delta_t):(i-1)])
beta_val_DIA.MI <- beta_function(DIA.MI.CCReturnMonthly[(i-delta_t):(i-1)], FTSEMIB.MI.CCReturnMonthly[(i-delta_t):(i-1)])
beta_xts_TEN.MI <- as.xts(beta_val_TEN.MI, order.by = index(TEN.MI.CCReturnMonthly[(i-1)]))
beta_xts_ENI.MI <- as.xts(beta_val_ENI.MI, order.by = index(ENI.MI.CCReturnMonthly[(i-1)]))
beta_xts_EXO.MI <- as.xts(beta_val_EXO.MI, order.by = index(EXO.MI.CCReturnMonthly[(i-1)]))
beta_xts_AZM.MI <- as.xts(beta_val_AZM.MI, order.by = index(AZM.MI.CCReturnMonthly[(i-1)]))
beta_xts_REC.MI <- as.xts(beta_val_REC.MI, order.by = index(REC.MI.CCReturnMonthly[(i-1)]))
beta_xts_DIA.MI <- as.xts(beta_val_DIA.MI, order.by = index(DIA.MI.CCReturnMonthly[(i-1)]))
if(is.null(TEN.MI_betas.xts)){
TEN.MI_betas.xts <- beta_xts_TEN.MI
ENI.MI_betas.xts <- beta_xts_ENI.MI
EXO.MI_betas.xts <- beta_xts_EXO.MI
AZM.MI_betas.xts <- beta_xts_AZM.MI
REC.MI_betas.xts <- beta_xts_REC.MI
DIA.MI_betas.xts <- beta_xts_DIA.MI
}else{
TEN.MI_betas.xts <- rbind(TEN.MI_betas.xts,beta_xts_TEN.MI)
ENI.MI_betas.xts <- rbind(ENI.MI_betas.xts,beta_xts_ENI.MI)
EXO.MI_betas.xts <- rbind(EXO.MI_betas.xts,beta_xts_EXO.MI)
AZM.MI_betas.xts <- rbind(AZM.MI_betas.xts,beta_xts_AZM.MI)
REC.MI_betas.xts <- rbind(REC.MI_betas.xts,beta_xts_REC.MI)
DIA.MI_betas.xts <- rbind(DIA.MI_betas.xts,beta_xts_DIA.MI)
}
}
# Visualizzazione Beta computati
plot(TEN.MI_betas.xts)
plot(ENI.MI_betas.xts)
plot(EXO.MI_betas.xts)
plot(AZM.MI_betas.xts)
plot(REC.MI_betas.xts)
plot(DIA.MI_betas.xts)
TEN.MI_betas <- as.xts(c(rep(NA,delta_t), as.numeric(TEN.MI_betas.xts)), order.by = index(TEN.MI.CCReturnMonthly))
ENI.MI_betas <- as.xts(c(rep(NA,delta_t), as.numeric(ENI.MI_betas.xts)), order.by = index(TEN.MI.CCReturnMonthly))
EXO.MI_betas <- as.xts(c(rep(NA,delta_t), as.numeric(EXO.MI_betas.xts)), order.by = index(TEN.MI.CCReturnMonthly))
AZM.MI_betas <- as.xts(c(rep(NA,delta_t), as.numeric(AZM.MI_betas.xts)), order.by = index(TEN.MI.CCReturnMonthly))
REC.MI_betas <- as.xts(c(rep(NA,delta_t), as.numeric(REC.MI_betas.xts)), order.by = index(TEN.MI.CCReturnMonthly))
DIA.MI_betas <- as.xts(c(rep(NA,delta_t), as.numeric(DIA.MI_betas.xts)), order.by = index(TEN.MI.CCReturnMonthly))
par(mfrow=c(1,1))
plot(TEN.MI_betas, type="l", main="Beta TEN.MI")
# Visualizzazione Beta computati
plot(TEN.MI_betas.xts)
par(mfrow=c(1,1))
plot(TEN.MI_betas, type="l", main="Beta TEN.MI")
